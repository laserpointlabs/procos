
# Project Architecture Documentation Maintenance

## When to Use This Rule

This rule triggers automatically when:
- **Service changes**: Adding/modifying services in `services/`
- **Infrastructure changes**: Updating Docker configurations
- **API modifications**: Changing endpoints or service interfaces
- **Documentation editing**: Working on architecture-related docs
- **Package dependencies**: Updating service dependencies

## Architecture Documentation Requirements

### **Mandatory Diagram Updates**

When making these changes, **automatically update** corresponding diagrams:

#### **Service Changes** → Update Service Architecture
- **File**: `docs/architecture/service-architecture.md`
- **Triggers**: New services, modified APIs, changed dependencies
- **Diagram Type**: Mermaid service relationship diagram
- **Include**: Service boundaries, API connections, data flow

#### **Infrastructure Changes** → Update Infrastructure Topology  
- **File**: `docs/architecture/infrastructure.md`
- **Triggers**: Container changes, port modifications, new databases
- **Diagram Type**: Mermaid deployment diagram
- **Include**: Containers, networks, volumes, ports

#### **Data Flow Changes** → Update Data Flow Diagrams
- **File**: `docs/architecture/data-flow.md`
- **Triggers**: New data sources, modified processing, storage changes
- **Diagram Type**: Mermaid flowchart
- **Include**: Data sources, transformations, storage, outputs

#### **System Overview Changes** → Update High-Level Architecture
- **File**: `docs/architecture/system-overview.md`
- **Triggers**: Major component additions, architectural pattern changes
- **Diagram Type**: Mermaid graph showing system components
- **Include**: Major subsystems, external integrations, user interactions

### **Architecture Documentation Structure**

Maintain this standardized structure:

```
docs/architecture/
├── system-overview.md          # High-level project architecture
├── service-architecture.md     # Microservices design & relationships  
├── data-flow.md               # Data processing and movement
├── infrastructure.md          # Container and deployment topology
├── security-architecture.md   # Security patterns and controls
├── integration-patterns.md    # External system integration
└── decision-records/          # Architecture Decision Records (ADRs)
    ├── ADR-001-microservices.md
    ├── ADR-002-database-choice.md
    └── ADR-XXX-topic.md
```

### **Mermaid Diagram Standards**

#### **Service Architecture Diagram Template**
```mermaid
graph TB
    subgraph "Frontend"
        UI[Project UI :3000]
    end
    
    subgraph "API Gateway"
        GATEWAY[API Gateway]
    end
    
    subgraph "Core Services"
        S1[Service 1 :3001]
        S2[Service 2 :3002]
        S3[Service 3 :3003]
        S4[Service 4 :3004]
        S5[Service 5 :3005]
    end
    
    subgraph "Data Layer"
        PG[(PostgreSQL :5432)]
        NEO[(Neo4j :7687)]
        REDIS[(Redis :6379)]
        MQ[(Message Broker :5672)]
    end
    
    UI --> GATEWAY
    GATEWAY --> S1
    GATEWAY --> S2
    GATEWAY --> S3
    S1 --> PG
    S2 --> NEO
    S3 --> REDIS
```

#### **Infrastructure Topology Template**
```mermaid
graph TB
    subgraph "Development Environment"
        subgraph "Application Stack"
            APP[Application Container]
            WORKER[Worker Container]
        end
        
        subgraph "Data Services"
            DB[(PostgreSQL)]
            CACHE[(Redis)]
            SEARCH[(Search Engine)]
        end
        
        subgraph "Message Broker"
            MQ[(Message Queue)]
        end
        
        subgraph "Monitoring"
            LOGS[Log Aggregator]
            METRICS[Metrics Collector]
        end
    end
    
    APP --> DB
    APP --> CACHE
    WORKER --> MQ
    WORKER --> SEARCH
    APP --> LOGS
    APP --> METRICS
```

#### **Data Flow Template**
```mermaid
flowchart LR
    subgraph "Input Sources"
        API[API Requests]
        FILE[File Uploads]
        STREAM[Data Streams]
    end
    
    subgraph "Processing"
        VALIDATE[Validation]
        TRANSFORM[Transformation]
        ENRICH[Enrichment]
    end
    
    subgraph "Storage"
        DB[(Database)]
        CACHE[(Cache)]
        ARCHIVE[(Archive)]
    end
    
    subgraph "Output"
        API_OUT[API Responses]
        NOTIFY[Notifications]
        EXPORT[Exports]
    end
    
    API --> VALIDATE
    FILE --> VALIDATE
    STREAM --> VALIDATE
    
    VALIDATE --> TRANSFORM
    TRANSFORM --> ENRICH
    
    ENRICH --> DB
    ENRICH --> CACHE
    
    DB --> API_OUT
    CACHE --> API_OUT
    DB --> NOTIFY
    DB --> EXPORT
```

### **Documentation Update Triggers**

#### **Service Layer Changes**
- **New service added** → Update service architecture diagram
- **API endpoint modified** → Update API documentation
- **Service dependency changed** → Update dependency graph
- **Service configuration updated** → Update deployment docs

#### **Infrastructure Changes**
- **New container added** → Update infrastructure topology
- **Port configuration changed** → Update port mapping docs
- **Volume mounts modified** → Update storage documentation
- **Network configuration updated** → Update network topology

#### **Data Layer Changes**
- **New database added** → Update data architecture diagram
- **Schema modifications** → Update data model documentation
- **Migration scripts** → Update migration documentation
- **Data flow changes** → Update data flow diagrams

#### **Security Changes**
- **Authentication updates** → Update security architecture
- **Authorization changes** → Update access control docs
- **Encryption modifications** → Update security patterns
- **Compliance requirements** → Update compliance documentation

### **Automated Documentation Updates**

#### **When Adding New Services**
1. **Update service architecture diagram**
2. **Add service documentation**
3. **Update API documentation**
4. **Update deployment configuration**
5. **Create service-specific tests**

#### **When Modifying Infrastructure**
1. **Update infrastructure topology**
2. **Update deployment scripts**
3. **Update environment configuration**
4. **Update monitoring configuration**
5. **Update backup procedures**

#### **When Changing Data Models**
1. **Update data flow diagrams**
2. **Update database schema docs**
3. **Create migration scripts**
4. **Update API documentation**
5. **Update test data**

### **Architecture Decision Records (ADRs)**

#### **ADR Template**
```markdown
# ADR-XXX: [Title]

## Status
[Proposed | Accepted | Deprecated | Superseded]

## Context
[Describe the forces at play, including technological, political, social, and project local]

## Decision
[Describe the decision and its rationale]

## Consequences
[Describe the resulting context, after applying the decision]

## Implementation
[Describe the implementation details]

## References
[Link to relevant documentation, discussions, etc.]
```

#### **Required ADRs**
- **ADR-001**: Technology stack selection
- **ADR-002**: Database choice and design
- **ADR-003**: API design patterns
- **ADR-004**: Security architecture
- **ADR-005**: Deployment strategy
- **ADR-006**: Monitoring and observability
- **ADR-007**: Testing strategy
- **ADR-008**: Data management approach

### **Quality Assurance**

#### **Documentation Review Checklist**
- [ ] All diagrams are current and accurate
- [ ] Service relationships are properly documented
- [ ] Data flows are clearly illustrated
- [ ] Infrastructure topology is up to date
- [ ] Security patterns are documented
- [ ] Integration points are clearly defined
- [ ] Deployment procedures are documented
- [ ] Monitoring and alerting are configured

#### **Architecture Validation**
- **Service boundaries** are clearly defined
- **Data ownership** is established
- **API contracts** are documented
- **Error handling** is consistent
- **Security controls** are implemented
- **Performance requirements** are met
- **Scalability patterns** are in place

---

**This ensures architecture documentation remains current and accurate as the project evolves.**
- Performance and security considerations documented

---

**This rule ensures DADMS architecture documentation stays synchronized with actual system implementation and design decisions.**