
# Project Testing & CI/CD Standards

## When to Use This Rule

This rule applies when working with:
- **Test files** (`.test.ts`, `.test.tsx`, `.spec.ts`, `.spec.tsx`)
- **Test directories** (`tests/`, `__tests__/`, `cypress/`)
- **Test configuration** (`jest.config.js`, `cypress.config.js`)
- **CI/CD pipelines** (GitHub Actions, package.json scripts)

## Testing Pyramid Standards

### **Unit Tests (70% of test coverage)**

#### **Service Layer Testing**
```typescript
// ✅ GOOD: Comprehensive service testing
import { ProjectService } from '../src/services/ProjectService';
import { MockDatabase } from './mocks/MockDatabase';

describe('ProjectService', () => {
  let projectService: ProjectService;
  let mockDb: MockDatabase;

  beforeEach(() => {
    mockDb = new MockDatabase();
    projectService = new ProjectService(mockDb);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createProject', () => {
    it('should create project with valid data', async () => {
      // Arrange
      const projectData = {
        name: 'Test Project',
        description: 'A test project',
        userId: 'user-123'
      };
      const expectedProject = { id: 'proj-456', ...projectData };
      mockDb.projects.create.mockResolvedValue(expectedProject);

      // Act
      const result = await projectService.createProject(projectData);

      // Assert
      expect(result).toEqual(expectedProject);
      expect(mockDb.projects.create).toHaveBeenCalledWith(projectData);
      expect(mockDb.projects.create).toHaveBeenCalledTimes(1);
    });

    it('should throw error for duplicate project name', async () => {
      // Arrange
      const projectData = { name: 'Existing Project', userId: 'user-123' };
      mockDb.projects.create.mockRejectedValue(new Error('Duplicate project name'));

      // Act & Assert
      await expect(projectService.createProject(projectData))
        .rejects.toThrow('Duplicate project name');
    });

    it('should validate required fields', async () => {
      // Arrange
      const invalidData = { description: 'Missing name' };

      // Act & Assert
      await expect(projectService.createProject(invalidData as any))
        .rejects.toThrow('Project name is required');
    });
  });
});

// ❌ BAD: Poor test structure
test('project stuff', async () => {
  const service = new ProjectService();
  const result = await service.createProject({ name: 'test' });
  expect(result).toBeDefined();
});
```

#### **React Component Testing**
```tsx
// ✅ GOOD: Comprehensive component testing
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ProjectCard } from '../src/components/ProjectCard';
import { ThemeProvider } from '../src/contexts/ThemeContext';

const mockProject = {
  id: 'proj-123',
  name: 'Test Project',
  description: 'A test project description',
  status: 'active' as const,
  createdAt: new Date('2023-01-01')
};

const renderWithTheme = (component: React.ReactElement) => {
  return render(
    <ThemeProvider>
      {component}
    </ThemeProvider>
  );
};

describe('ProjectCard', () => {
  it('renders project information correctly', () => {
    renderWithTheme(<ProjectCard project={mockProject} />);
    
    expect(screen.getByText('Test Project')).toBeInTheDocument();
    expect(screen.getByText('A test project description')).toBeInTheDocument();
    expect(screen.getByText('Active')).toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', async () => {
    const mockOnEdit = jest.fn();
    renderWithTheme(
      <ProjectCard project={mockProject} onEdit={mockOnEdit} />
    );
    
    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockProject);
  });

  it('shows loading state during edit operation', async () => {
    const mockOnEdit = jest.fn().mockImplementation(() => new Promise(resolve => setTimeout(resolve, 100)));
    
    renderWithTheme(
      <ProjectCard project={mockProject} onEdit={mockOnEdit} />
    );
    
    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);
    
    expect(screen.getByText('Editing...')).toBeInTheDocument();
    expect(editButton).toBeDisabled();
    
    await waitFor(() => {
      expect(screen.getByText('Edit')).toBeInTheDocument();
    });
  });

  it('handles error states gracefully', async () => {
    const mockOnEdit = jest.fn().mockRejectedValue(new Error('Edit failed'));
    
    renderWithTheme(
      <ProjectCard project={mockProject} onEdit={mockOnEdit} />
    );
    
    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);
    
    await waitFor(() => {
      expect(screen.getByText('Edit')).toBeInTheDocument();
    });
    
    expect(editButton).not.toBeDisabled();
  });
});

// ❌ BAD: Poor component testing
test('ProjectCard renders', () => {
  render(<ProjectCard project={mockProject} />);
  expect(screen.getByText('Test Project')).toBeInTheDocument();
});
```

### **Integration Tests (20% of test coverage)**

#### **API Endpoint Testing**
```typescript
// ✅ GOOD: Comprehensive API testing
import request from 'supertest';
import { app } from '../src/app';
import { setupTestDatabase, teardownTestDatabase } from './test-utils';

describe('Project API', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });

  afterAll(async () => {
    await teardownTestDatabase();
  });

  beforeEach(async () => {
    // Clear test data between tests
    await request(app).delete('/api/test/clear');
  });

  describe('POST /api/projects', () => {
    it('should create a new project successfully', async () => {
      const projectData = {
        name: 'New Test Project',
        description: 'A new test project',
        status: 'draft'
      };

      const response = await request(app)
        .post('/api/projects')
        .send(projectData)
        .expect(201);

      expect(response.body).toMatchObject({
        id: expect.any(String),
        name: projectData.name,
        description: projectData.description,
        status: projectData.status,
        createdAt: expect.any(String)
      });
    });

    it('should return 400 for invalid project data', async () => {
      const invalidData = {
        description: 'Missing name field'
      };

      const response = await request(app)
        .post('/api/projects')
        .send(invalidData)
        .expect(400);

      expect(response.body).toMatchObject({
        error: 'Validation failed',
        details: expect.arrayContaining([
          expect.objectContaining({
            field: 'name',
            message: expect.any(String)
          })
        ])
      });
    });

    it('should return 409 for duplicate project name', async () => {
      const projectData = {
        name: 'Duplicate Project',
        description: 'First project'
      };

      // Create first project
      await request(app)
        .post('/api/projects')
        .send(projectData)
        .expect(201);

      // Try to create duplicate
      const response = await request(app)
        .post('/api/projects')
        .send(projectData)
        .expect(409);

      expect(response.body).toMatchObject({
        error: 'Project with this name already exists'
      });
    });
  });

  describe('GET /api/projects', () => {
    it('should return paginated projects', async () => {
      // Create test projects
      const projects = [
        { name: 'Project 1', description: 'First project' },
        { name: 'Project 2', description: 'Second project' },
        { name: 'Project 3', description: 'Third project' }
      ];

      for (const project of projects) {
        await request(app)
          .post('/api/projects')
          .send(project);
      }

      const response = await request(app)
        .get('/api/projects?limit=2&page=1')
        .expect(200);

      expect(response.body).toMatchObject({
        projects: expect.arrayContaining([
          expect.objectContaining({
            name: expect.any(String),
            description: expect.any(String)
          })
        ]),
        pagination: {
          page: 1,
          limit: 2,
          total: 3,
          totalPages: 2
        }
      });

      expect(response.body.projects).toHaveLength(2);
    });

    it('should filter projects by status', async () => {
      // Create projects with different statuses
      await request(app)
        .post('/api/projects')
        .send({ name: 'Active Project', status: 'active' });

      await request(app)
        .post('/api/projects')
        .send({ name: 'Draft Project', status: 'draft' });

      const response = await request(app)
        .get('/api/projects?status=active')
        .expect(200);

      expect(response.body.projects).toHaveLength(1);
      expect(response.body.projects[0].name).toBe('Active Project');
    });
  });
});
```

### **E2E Tests (10% of test coverage)**

#### **Critical User Journey Testing**
```typescript
// ✅ GOOD: E2E testing with Cypress
describe('Project Management E2E', () => {
  beforeEach(() => {
    cy.visit('/');
    cy.login('testuser@example.com', 'password123');
  });

  it('should allow user to create and manage projects', () => {
    // Navigate to projects page
    cy.visit('/projects');
    
    // Create new project
    cy.get('[data-testid="create-project-btn"]').click();
    cy.get('[data-testid="project-name-input"]').type('My New Project');
    cy.get('[data-testid="project-description-input"]').type('A test project for E2E testing');
    cy.get('[data-testid="project-status-select"]').select('draft');
    cy.get('[data-testid="save-project-btn"]').click();
    
    // Verify project was created
    cy.url().should('include', '/projects/');
    cy.get('[data-testid="project-name"]').should('contain', 'My New Project');
    cy.get('[data-testid="project-status"]').should('contain', 'Draft');
    
    // Edit project
    cy.get('[data-testid="edit-project-btn"]').click();
    cy.get('[data-testid="project-name-input"]').clear().type('Updated Project Name');
    cy.get('[data-testid="save-project-btn"]').click();
    
    // Verify changes were saved
    cy.get('[data-testid="project-name"]').should('contain', 'Updated Project Name');
    
    // Delete project
    cy.get('[data-testid="delete-project-btn"]').click();
    cy.get('[data-testid="confirm-delete-btn"]').click();
    
    // Verify project was deleted
    cy.url().should('eq', Cypress.config().baseUrl + '/projects');
    cy.get('[data-testid="project-list"]').should('not.contain', 'Updated Project Name');
  });

  it('should handle validation errors gracefully', () => {
    cy.visit('/projects');
    cy.get('[data-testid="create-project-btn"]').click();
    
    // Try to save without required fields
    cy.get('[data-testid="save-project-btn"]').click();
    
    // Verify validation messages
    cy.get('[data-testid="name-error"]').should('contain', 'Name is required');
    
    // Fill in required field and save
    cy.get('[data-testid="project-name-input"]').type('Valid Project');
    cy.get('[data-testid="save-project-btn"]').click();
    
    // Verify success
    cy.url().should('include', '/projects/');
  });

  it('should handle network errors gracefully', () => {
    // Intercept API calls to simulate network errors
    cy.intercept('POST', '/api/projects', { statusCode: 500 }).as('createProjectError');
    
    cy.visit('/projects');
    cy.get('[data-testid="create-project-btn"]').click();
    cy.get('[data-testid="project-name-input"]').type('Network Test Project');
    cy.get('[data-testid="save-project-btn"]').click();
    
    // Wait for the intercepted request
    cy.wait('@createProjectError');
    
    // Verify error handling
    cy.get('[data-testid="error-message"]').should('contain', 'Failed to create project');
    cy.get('[data-testid="retry-btn"]').should('be.visible');
  });
});
```

## CI/CD Pipeline Standards

### **GitHub Actions Workflow**
```yaml
# ✅ GOOD: Comprehensive CI/CD pipeline
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linting
      run: npm run lint
    
    - name: Run type checking
      run: npm run type-check
    
    - name: Run unit tests
      run: npm run test:unit -- --coverage --watchAll=false
    
    - name: Run integration tests
      run: npm run test:integration -- --watchAll=false
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

  e2e:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Start application
      run: npm run start:test &
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
    
    - name: Wait for application
      run: npx wait-on http://localhost:3000
    
    - name: Run E2E tests
      run: npm run test:e2e
      env:
        CYPRESS_baseUrl: http://localhost:3000

  security:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run security audit
      run: npm audit --audit-level=high
    
    - name: Run SAST scan
      uses: github/codeql-action/init@v2
      with:
        languages: javascript
    
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

  build:
    runs-on: ubuntu-latest
    needs: [test, e2e, security]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          project/app:latest
          project/app:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Deploy to production
      run: |
        echo "Deploying to production..."
        # Add deployment steps here
```

### **Package.json Scripts**
```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=unit",
    "test:integration": "jest --testPathPattern=integration",
    "test:e2e": "cypress run",
    "test:coverage": "jest --coverage",
    "test:watch": "jest --watch",
    "test:ci": "jest --ci --coverage --watchAll=false",
    "lint": "eslint . --ext .ts,.tsx,.js,.jsx",
    "lint:fix": "eslint . --ext .ts,.tsx,.js,.jsx --fix",
    "type-check": "tsc --noEmit",
    "build": "tsc && vite build",
    "start": "node dist/server.js",
    "start:dev": "vite dev",
    "start:test": "NODE_ENV=test node dist/server.js",
    "docker:build": "docker build -t project/app .",
    "docker:run": "docker run -p 3000:3000 project/app",
    "docker:test": "docker run --rm project/app npm test"
  }
}
```

## Test Configuration Standards

### **Jest Configuration**
```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/*.test.ts',
    '!src/**/*.spec.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testTimeout: 10000,
  verbose: true,
  clearMocks: true,
  restoreMocks: true
};
```

### **Cypress Configuration**
```javascript
// cypress.config.js
const { defineConfig } = require('cypress');

module.exports = defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    supportFile: 'cypress/support/e2e.ts',
    specPattern: 'cypress/e2e/**/*.cy.ts',
    video: false,
    screenshotOnRunFailure: true,
    defaultCommandTimeout: 10000,
    requestTimeout: 10000,
    responseTimeout: 10000,
    viewportWidth: 1280,
    viewportHeight: 720,
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
  },
  component: {
    devServer: {
      framework: 'react',
      bundler: 'vite',
    },
  },
});
```

## Quality Gates

### **Pre-commit Hooks**
```json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "pre-push": "npm run test:ci"
    }
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": [
      "eslint --fix",
      "prettier --write",
      "jest --bail --findRelatedTests"
    ],
    "*.{json,md,yml,yaml}": [
      "prettier --write"
    ]
  }
}
```

### **Code Coverage Requirements**
- **Unit Tests**: Minimum 80% coverage
- **Integration Tests**: Minimum 70% coverage
- **E2E Tests**: Critical user journeys covered
- **Security Tests**: All authentication/authorization flows tested

### **Performance Testing**
```typescript
// ✅ GOOD: Performance testing
import { performance } from 'perf_hooks';

describe('Performance Tests', () => {
  it('should load project list within 2 seconds', async () => {
    const start = performance.now();
    
    const response = await request(app)
      .get('/api/projects')
      .expect(200);
    
    const end = performance.now();
    const duration = end - start;
    
    expect(duration).toBeLessThan(2000); // 2 seconds
    expect(response.body.projects).toBeDefined();
  });

  it('should handle concurrent requests efficiently', async () => {
    const concurrentRequests = 10;
    const promises = Array.from({ length: concurrentRequests }, () =>
      request(app).get('/api/projects')
    );
    
    const start = performance.now();
    const responses = await Promise.all(promises);
    const end = performance.now();
    const duration = end - start;
    
    expect(duration).toBeLessThan(5000); // 5 seconds for 10 concurrent requests
    responses.forEach(response => {
      expect(response.status).toBe(200);
    });
  });
});
```

---

**These testing standards ensure comprehensive, reliable, and maintainable test coverage across the entire project.**
- **Security scans**: Run on every pull request

---

**These testing standards ensure DADMS maintains high quality, reliability, and confidence in deployments.**